#!/usr/bin/env python
""" Strips keywords from the input file that are not supported in a given build of cp2k. 

Usage: cp2k_strip_unsupported_keywords.py run.inp cp2k_input.xml

The latter xml is generated by calling the corresponding executable with --xml only.
"""
import sys
import xml.etree.ElementTree as ET

if len(sys.argv) != 3:
	print 'Usage: cp2k_strip_unsupported_keywords.py run.inp cp2k_input.xml'
	exit(2)

class Map(dict):
	def __init__(self, *args, **kwargs):
		super(Map, self).__init__(*args, **kwargs)
		for arg in args:
			if isinstance(arg, dict):
				for k, v in arg.iteritems():
					if isinstance(v, (list, tuple)):
						v = [Map(_) if isinstance(_, dict) else _ for _ in v]
					if isinstance(v, dict):
						v = Map(v)
					self[k] = v

		if kwargs:
			for k, v in kwargs.iteritems():
				self[k] = v

	def __getattr__(self, attr):
		return self.get(attr)

	def __setattr__(self, key, value):
		self.__setitem__(key, value)

	def __setitem__(self, key, value):
		super(Map, self).__setitem__(key, value)
		if type(value) is dict:
			value = Map(value)
		self.__dict__.update({key: value})

	def __delattr__(self, item):
		self.__delitem__(item)

	def __delitem__(self, key):
		super(Map, self).__delitem__(key)
		del self.__dict__[key]

	def traverse(self, keys):
		r = self
		for k in keys:
			r = r[k]
			if isinstance(r, list):
				r = r[-1]
		return r

def _recognize_line(line):
	parts = line.split()
	if len(parts) == 1:
		return parts[0], None
	if len(parts) == 2:
		try:
			return parts[0], float(parts[1])
		except ValueError:
			return tuple(parts)
	try:
		return parts[0], tuple(map(float, parts[1:]))
	except ValueError:
		return parts[0], tuple(parts[1:])

def _parse_input_file(lines):
	sections = []
	result = Map()
	for no, line in enumerate(lines):
		line = line.strip()
		if len(line) == 0:
			continue
		if line.startswith('&END'):
			ending = line[4:].strip()
			if ending != '' and (len(sections) == 0 or ending != sections[-1]):
				raise ValueError('Trying to end the %s section with %s' % (sections[-1], ending))
			sections = sections[:-1]
			continue
		if line.startswith('&'):
			section = (line.split()[0][1:]).strip()
			if section in result.traverse(sections):
				if isinstance(result.traverse(sections)[section], Map):
					result.traverse(sections)[section] = [result.traverse(sections)[section], Map()]
				else:
					result.traverse(sections)[section].append(Map())
			else:
				result.traverse(sections)[section] = Map()
			sections.append(section)
			continue
		if not (line.startswith('#') or line.startswith('!')):
			k, v = _recognize_line(line)
			q = result.traverse(sections)
			if k in q:
				if isinstance(q[k], list):
					q[k].append(v)
				else:
					q[k] = [q[k], v]
			else:
				q[k] = v
			continue
	return result

inputfile, reference = sys.argv[1:]
config = _parse_input_file(open(inputfile).readlines())
valid_tree = ET.parse(reference)

def purge(candidate, ref, parent_sections = [], tbd=[]):
	sections = ref.findall('SECTION')
	section_names = [_.findall('NAME')[0].text for _ in sections]
	has_defaults = [len(_.findall('DEFAULT_KEYWORD')) for _ in sections]
	keywords = ref.findall('KEYWORD')
	keyword_names = [_.findall('NAME')[0].text for _ in keywords]
	alias_names = [[x.text for x in _.findall('NAME')] for _ in keywords]
	aliases = sum(alias_names, [])

	drop = []
	for element in list(candidate.iterkeys()):
		if element in section_names:
			this_section = sections[section_names.index(element)]
			this_defaults = has_defaults[section_names.index(element)]
			if this_defaults:
				continue
			if type(candidate[element]) == Map:
				retval, tbd = purge(candidate[element], this_section, parent_sections + [element], tbd)
				#if retval is not None:
				candidate[element] = retval
				#else:
				#	pass
					#del candidate[element]
			elif type(candidate[element]) == list:
				retvals = []
				for _ in candidate[element]:
					r, tbd = purge(_, this_section, parent_sections + [element], tbd) 
					if r is not None:
						retvals.append(r)
				candidate[element] = retvals
			else:
				continue
			
		elif element not in keyword_names and element not in aliases:
			print '# Invalid entry found:', element, parent_sections
			tbd.append(element)
	for tbd in drop:
		del candidate[drop]
	return candidate, tbd

def to_string(data, indent=0, parent=[]):
	indentation = indent * ' '
	try:
		if type(data) == list:
			for entry in data:
				to_string(entry, indent, parent)
		elif type(data) == tuple:
			s = ' '.join(map(str, data))
			print '%s  %s' % (indentation, s)
		else:
			for entry in data:
				if len(parent) > 0 and parent[-1] in 'COORD VELOCITY'.split():
					if type(data[entry]) == list:
						for line in data[entry]:
							s = ' '.join(map(str, line)).replace(',', ' ')
							print '%s%s %s' % (indentation, entry, s)
						continue
					if type(data[entry]) == tuple:
						s = ' '.join(map(str, data[entry])).replace(',', ' ')
						print '%s%s %s' % (indentation, entry, s)
						continue
				print '%s&%s' % (indentation, entry)
				if type(data[entry]) == list or type(data[entry]) == Map:
					to_string(data[entry], indent+2, parent + [entry])
				else:
					if type(data[entry]) == tuple:
						s = ' '.join(map(str, data[entry]))
					else:
						s = data[entry]
					print '%s  %s %s' % (indentation, entry, s)
				print '%s&END %s' % (indentation, entry)
	except:
		#print data
		raise

purged, tbd = purge(config, valid_tree)
for line in open(inputfile):
	found = False
	for t in tbd:
		if t in line:
			found = True
	if not found:
		print line[:-1]
#to_string(purged)
#print config['GLOBAL']
#print valid_tree['GLOBAL']